---
category:
- Uncategorized
creator: admin
date: 2023-03-27T02:55:38
layout: layout.njk
tags:
- golang
- Programming
- Security
title: A peek inside pinentry
type: post
---
<p>Recently I got a new work computer, and have been taking the opportunity to rework my <a href="https://github.com/jmhobbs/dotfiles">dotfiles</a>, configs and install scripts while setting up the new machine.  In the process I was reading through options for gpg-agent and started wondering, how exactly does pinentry work?</p>
<h2>pinentry</h2>
<p><a href="https://www.gnupg.org/related_software/pinentry/index.html">pinentry</a> is: "...a small collection of dialog programs that allow GnuPG to read passphrases and PIN numbers in a secure manner...".  I see it regularly when using my <a href="https://www.velvetcache.org/2018/05/30/a-new-gpg-key">Yubikey</a> to sign commits or connect over SSH.  Specifically, I see <a href="https://github.com/GPGTools/pinentry">pinentry-mac from GPGTools</a>.</p>
<p><img src="https://static.velvetcache.org/pages/2023/03/25/a-peek-inside-pinentry/pinentry-mac.png" alt="pinentry-mac asking for my Yubikey PIN" style="width: 80%; max-width: 545px;" /></p>
<p>Initially, I just ran <tt>pinentry-mac</tt> and was presented with no dialog, just this inscrutable message:</p>
<p><pre lang="shell" class="command-line">jmhobbs:~ ? pinentry-mac
OK Pleased to meet you
</pre></p>
<p>The help flag did not enlighten me either:</p>
<p><pre>jmhobbs:~ ? pinentry-mac --help
pinentry-mac (pinentry) 1.1.1
Copyright (C) 2016 g10 Code GmbH
License GPLv2+: GNU GPL version 2 or later <https://www.gnu.org/licenses/>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Usage: pinentry-mac [options] (-h for help)
Ask securely for a secret and print it to stdout.
Options:
 -d, --debug                Turn on debugging output
 -D, --display DISPLAY      Set the X display
 -T, --ttyname FILE         Set the tty terminal node name
 -N, --ttytype NAME         Set the tty terminal type
 -C, --lc-ctype STRING      Set the tty LC_CTYPE value
 -M, --lc-messages STRING   Set the tty LC_MESSAGES value
 -o, --timeout SECS         Timeout waiting for input after this many seconds
 -g, --no-global-grab       Grab keyboard only while window is focused
 -W, --parent-wid           Parent window ID (for positioning)
 -c, --colors STRING        Set custom colors for ncurses
 -a, --ttyalert STRING      Set the alert mode (none, beep or flash)

Please report bugs to &lt;https://bugs.gnupg.org&gt;.</pre></p>
<p>Clearly, there was more to be found here.  Luckily, there are docs. Of a sort.  Pinentry does not ship with a <tt>man</tt> file, but it does have an <tt>info</tt> file, from which pretty much all you need to learn can be found.</p>

<h2>The Assuan Protocol</h2>
<p>Pinentry uses a text based protocol called the <a href="https://www.gnupg.org/documentation/manuals/assuan/index.html">Assuan protocol</a>. This protocol was developed for the GnuPG project, and is very simple.  You have a client and a server, communicating generally through a pipe or a unix socket.  Each message is composed of a command and parameters, which are optional. The command comes first and is space separated from the parameters.  Each message is terminated by a carriage return + line feed, or just a line feed.</p>
<p>There are a number of messages and commands defined by the protocol (<tt>OK</tt>, <tt>QUIT</tt>, <tt>RESET</tt>, etc.) but each application extends these with it's own commands.</p>
<p>In our case, when running from the terminal, we are the client and pinentry is the server.</p>


<h3>pinentry Specifics</h3>
<p>There are three documented actions you can perform which actually display a prompt, they are:</p>

<table>
<thead>
<tr>
<th>Command</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><tt>GETPIN</tt></td>
<td>Ask the user for a PIN or passphrase</td>
</tr>
<tr>
<td><tt>CONFIRM</tt></td>
<td>Ask for confirmation</td>
</tr>
<tr>
<td><tt>MESSAGE</tt></td>
<td>Show a message</td>
</tr>
</tbody>
</table>

<p>With this knowledge in hand, we can now pop up a dialog and get a secret.</p>
<p><img src="https://static.velvetcache.org/pages/2023/03/25/a-peek-inside-pinentry/pinentry-demo.gif" alt="triggering pinentry-mac to ask for a pin" style="width: 80%; max-width: 700px;" /></p>
<p>That's neat, but we can do better.  <tt>pinentry</tt> also has a set of documented configuration commands. These are outlined in much more detail in the info documentation.</p>
<table>
<thead>
<tr>
<th>Command</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><tt>SETTIMEOUT [int]</tt></td>
<td>Set the timeout before returning an error</td>
</tr>
<tr>
<td><tt>SETDESC [description]</tt></td>
<td>Set the descriptive text to display</td>
</tr>
<tr>
<td><tt>SETPROMPT [prompt]</tt></td>
<td>Set the prompt to show</td>
</tr>
<tr>
<td><tt>SETTITLE [title]</tt></td>
<td>Set the window title</td>
</tr>
<tr>
<td><tt>SETOK [text]</tt></td>
<td>Set the button texts (confirmation button)</td>
</tr>
<tr>
<td><tt>SETCANCEL [text]</tt></td>
<td>Set the button texts (cancel button)</td>
</tr>
<tr>
<td><tt>SETNOTOK [text]</tt></td>
<td>Set the button texts (non-affirmative button)</td>
</tr>
<tr>
<td><tt>SETERROR [error]</tt></td>
<td>Set the Error text</td>
</tr>
<tr>
<td><tt>SETREPEAT</tt></td>
<td>Display a second input to confirm the passphrase</td>
</tr>
<tr>
<td><tt>SETQUALITYBAR</tt></td>
<td>Enable a passphrase quality indicator</td>
</tr>
<tr>
<td><tt>SETQUALITYBAR_TT [string]</tt></td>
<td>Set the tooltip value for the passphrase quality indicator</td>
</tr>
<tr>
<td><tt>OPTION constraints-enforce</tt></td>
<td>Enable enforcement of passphrase constraints</td>
</tr>
<tr>
<td><tt>OPTION constraints-hint-short=[string]</tt></td>
<td>Inform the user of passphrase constraints</td>
</tr>
<tr>
<td><tt>OPTION constraints-hint-long=[string]</tt></td>
<td>Inform the user of passphrase constraints</td>
</tr>
<tr>
<td><tt>SETGENPIN</tt></td>
<td>Enable an action for generating a passphrase</td>
</tr>
<tr>
<td><tt>SETGENPIN_TT [tooltip]</tt></td>
<td>Provide a tooltip for the passphrase generation action</td>
</tr>
<tr>
<td><tt>OPTION formatted-passphrase</tt></td>
<td>Enable passphrase formatting</td>
</tr>
<tr>
<td><tt>OPTION formatted-passphrase-hint=[text]</tt></td>
<td>Provide a hint for the user if passphrase formatting is enabled</td>
</tr>
<tr>
<td><tt>OPTION [ttyname|ttytype|lc-ctype]=[value]</tt></td>
<td>Set/configure the output device</td>
</tr>
<tr>
<td><tt>OPTION default-[ok|cancel|prompt]=[string]</tt></td>
<td>Set the default strings for translations</td>
</tr>
<tr>
<td><tt>OPTION allow-external-password-cache</tt></td>
<td>Enable passphrase caching</td>
</tr>
<tr>
<td><tt>SETKEYINFO [key identifier]</tt></td>
<td>Set a stable key identifier for caching</td>
</tr>
</tbody>
</table>
<p>Using some of these we can customize our prompt.</p>
<p><img src="https://static.velvetcache.org/pages/2023/03/25/a-peek-inside-pinentry/pinentry-options.gif" alt="triggering pinentry-mac to ask for a pin after setting options" style="width: 80%; max-width: 700px;" /></p>
<h2>Writing Our Client</h2>
<p>That's great, but obviously we don't want to manually control <tt>pinentry</tt>, we want to drive it from a separate application, just like <tt>gpg-agent</tt> does. Writing up a basic assuan protocol client isn't too complicated.  The spec says messages should be 1000 bytes or smaller, so we have a defined buffer size.</p>
<p><pre><code class="language-go">func (c *Client) Read() (Response, error) {
  resp := Response{}

  buf := make([]byte, 1000)
  _, err := c.source.Read(buf)
  if err != nil {
    return resp, err
  }</code></pre></p>
<p>There is a limited set of valid server responses, so we do the lazy thing and split the returned buffer on space bytes and handle each case.</p>
<p><pre><code class="language-go">split := bytes.SplitN(buf[:bytes.IndexRune(buf, '\n')], []byte{' '}, 2)

switch string(split[0]) {
case "OK":
  resp.Type = Ok
  resp.Comment = string(remainingParameters(split))
case "#":
  resp.Type = Comment
  resp.Comment = string(remainingParameters(split))
case "ERR":
  resp.Type = Error
  resp.Code, resp.Description = innerSplit(split)
case "D":
  resp.Type = Data
  resp.Data = remainingParameters(split)
case "S":
  resp.Type = Status
  resp.Status, resp.Keyword = innerSplit(split)
case "INQUIRE":
  resp.Type = Inquire
  resp.Keyword, resp.Parameters = innerSplit(split)
default:
  return resp, fmt.Errorf("unknown command: %q", string(split[0]))
}</code></pre></p>
<p>Client commands are a lot more varied, but we don't have to parse them only generate them.  The one variation here is we need to escape them using <tt>%[hex-value]</tt>.  So a line feed is <tt>%0A</tt>, carriage return is <tt>%0D</tt> and % itself is <tt>%25</tt>.</p>
<p><pre><code class="language-go">func Escape(input []byte) []byte {
	if input == nil {
		return nil
	}
	return bytes.ReplaceAll(
		bytes.ReplaceAll(
			bytes.ReplaceAll(
				input,
				[]byte{'%'},
				[]byte{'%', '2', '5'},
			),
			[]byte{'\n'},
			[]byte{'%', '0', 'A'},
		),
		[]byte{'\r'},
		[]byte{'%', '0', 'D'},
	)
}

func RequestGeneric(command string, parameters []byte) Request {
	var msg []byte
	if len(parameters) == 0 {
		msg = []byte(command)
	} else {
		buf := bytes.NewBufferString(command)
		buf.Write([]byte{' '})
		buf.Write(Escape(parameters))
		msg = buf.Bytes()
	}

	return func() []byte {
		return msg
	}
}

var (
	RequestBye   = RequestGeneric("BYE", nil)
	RequestReset = RequestGeneric("RESET", nil)
	RequestEnd   = RequestGeneric("END", nil)
	RequestHelp  = RequestGeneric("HELP", nil)
	RequestQuit  = RequestGeneric("QUIT", nil)
	RequestNOP   = RequestGeneric("NOP", nil)
)</code></pre></p>
<p>We can use these basics to create an API around the <tt>pinentry</tt> specific commands.  Building up a queue of commands, exec-ing out pinentry and then running commands over <tt>stdin</tt> and reading responses over <tt>stdout</tt>.  We end up with a fairly tidy (if incomplete) API.</p>
<p><pre><code class="language-go">pe := pinentry.New("pinentry-mac").
  SetDescription("What's your favorite mythological animal?").
  SetPrompt("Animal:").
  SetButtonOk("They're the best.").
  SetButonCancel("I'm not telling you.")

defer pe.Close()

secret, err := pe.GetPIN()
if err != nil {
  panic(err)
}</code></pre></p>
<p><img src="https://static.velvetcache.org/pages/2023/03/25/a-peek-inside-pinentry/pinentry-unicorn.gif" alt="triggering pinentry-mac to ask for a mythological animal" style="width: 80%; max-width: 700px;" /></p>
<h3><tt>SETQUALITYBAR</tt> &amp; <tt>INQUIRE</tt></h3>
<p>The final step to understanding is closing the loop of an interactive element between client and server.  <tt>pinentry</tt> can show a strength meter using <tt>SETQUALITYBAR</tt>.  Instead of having it's own logic of what makes a strong password, it delegates this to the connected client, allowing us to implement our own quality rules.  It does this through the use of <tt>INQUIRE</tt>.</p>
<p>First, we need to establish what makes a good quality answer for our dialog.  Obviously the unicorn is the undisputed best mythological animal, so we should use that as a measure of quality.  A simple way to compare sequences is the <a href="https://en.wikipedia.org/wiki/Levenshtein_distance">Levenshtein distance</a> between them.  That is, the number of insertions, deletions and substitutions required to transform one sequence into another.  For example, transforming "lawn" into "flaw" is a distance of 2.  We insert an "f" at the beginning and delete the "n" at the end.</p>
<p>Levenshtein distance can be calculated in a number of ways, I chose one of the simpler methods, the <a href="https://en.wikipedia.org/wiki/Wagner%E2%80%93Fischer_algorithm">Wagnerâ€“Fischer algorithm</a>.</p>
<p><pre><code class="language-go">func levenshtein_distance(desired, target string) int {
  rows := len(desired) + 1
  cols := len(target) + 1

  distributions := make([][]int, rows)
  for r := 0; r < rows; r++ {
    distributions[r] = make([]int, cols)
    distributions[r][0] = r
  }
  for c := 1; c < cols; c++ {
    distributions[0][c] = c
  }

  for col := 1; col < cols; col++ {
    for row := 1; row < rows; row++ {
      cost := 1
      if desired[row-1] == target[col-1] {
        cost = 0
      }
      distributions[row][col] = min(
        distributions[row-1][col]+1,
        distributions[row][col-1]+1,
        distributions[row-1][col-1]+cost,
      )
    }
  }

  return distributions[rows-1][cols-1]
}</code></pre></p>
<p>The correct answer, "unicorn" is 7 characters long, and we have the range -100 to 100, so let's split that into 7 chunks of about 28 points. So our score will be <tt>100 - ( [LD] * 28 )</tt>.  Unfortunately, in testing <tt>pinentry-mac</tt> treated scores as <tt>abs(&lt;score&gt;)</tt> which meant negative values looked pretty spot on.  To work around that is decidedly against the documented behavior "Negative values will be displayed in red." but we will just work around it.</p>
<p><pre><code class="language-go">func quality(input string) int {
  qlty := 100 - (levenshtein_distance("unicorn", strings.ToLower(input)) * 14)
  if qlty < 0 {
    return 0
  }
  return qlty
}</code></pre></p>
<p>With that in place, we get this lovely, unicorn affirming quality bar.</p>
<p><img src="https://static.velvetcache.org/pages/2023/03/25/a-peek-inside-pinentry/pinentry-quality.gif" alt="triggering pinentry-mac to ask for a mythological animal" style="width: 80%; max-width: 700px;" /></p>
<h2>The Other Side</h2>
<p>That's it, I feel like I now know, more or less, how <tt>pinentry</tt> works.  It's not the most elegant, nor the best documented, but it's effective and relatively simple.</p>
<p>It's simple enough, that it wouldn't be wild to implement your own <tt>pinentry</tt> with whatever GUI or TUI toolkit you might have around, things like <a href="https://github.com/t-8ch/pinentry-bemenu">pinentry-bemenu</a> for a trimmed down version that fits in with sway.  I'll leave that for another day however, as there are plenty of <tt>pinentry</tt> implementations already.</p>
<p>All the code used in this post is available on GitHub: <a href="https://github.com/jmhobbs/pinentry-client">github.com/jmhobbs/pinentry-client</a></p>
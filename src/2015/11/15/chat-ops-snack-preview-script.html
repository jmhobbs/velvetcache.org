---
category:
- Geek
creator: admin
date: 2015-11-15T06:06:07
layout: layout.njk
permalink: /2015/11/15/chat-ops-snack-preview-script/
tags:
- Automation
- ChatOps
- ImageMagick
- Pack
- Python
- S3
title: 'ChatOps: Snack Preview Script'
type: post
wp_id: "2644"
---
<p>One of the things we've built at Pack is <a href="http://snack.packdog.com/" target="_blank">Snack</a>, an iOS app which shows users five great dog photos every day.</p>
<p>Ideally, each Snack would be thematic, and curated.  However, curation doesn't always get done.  Either no theme is apparent, or we just don't get to it in time.</p>
<p>When there is no curated snack, we draw from our <a href="http://packdog.com/home/editors-picks" target="_blank">Editors Picks</a>, a collection of the best dog photos available.  This gives us quality content, even when we don't have the chance to pick all five by hand.</p>
<p>There is a downside to this though.  Some of our editors picks are specific to an event or time period.  Like Christmas or Halloween photos.  These wouldn't be very good in a Snack in the middle of May.</p>
<p>So how do we balance the light editorial touch while making sure the random snacks are cohesive?</p>
<p>My solution was a preview injected into our chat.  Every day a script grabs tomorrows Snack, makes a composite, and sends it into Slack for us to review.  If we see something is off, we jump into the admin and fix it.</p>
<p>It's fairly brute force, but a good example of centralizing tools around chat, which is something we try to do.  First we get the photo information, then we download each photo.  We take those and use ImageMagick to create a captioned composite.  Finally, we upload that to S3 and send the link to Slack.</p>
<p style="text-align: center;"><img src="http://static.velvetcache.org/pages/2015/11/15/chat-ops-snack-preview-script/snack_2015-11-13.jpg" style="width: 90%;" /></p>
<p>This first listing is pretty simple.  We just send a request for tomorrows Snack JSON from the public API.  You might wonder why we don't just set <tt>day_requested</tt> to <tt>tomorrow</tt>, but the API doesn't support that, and neither does the logic of the app.  This runs on a cron job which mails failed runs to us using <a href="http://habilis.net/cronic/" target="_blank">cronic</a>, so we call <tt>raise_for_status()</tt> to explicitly fail on bad HTTP requests.</p>
<p><pre class="lang:python start-line:10 decode:true " title="snack-comp.py" >tomorrow = datetime.date.today() + datetime.timedelta(days=1)

response = requests.get('http://packdog.com/api/snack.json',
                        params={'day_requested': 'today',
                                'year': tomorrow.year,
                                'month': tomorrow.month, 
                                'day': tomorrow.day})

response.raise_for_status()
result = response.json()
</pre></p>
<p>This next section shells out to download each image into a temporary file.  Order matters in a Snack, so we use a counter instead of taking random filenames.</p>
<p><pre class="lang:python start-line:21 decode:true " title="snack-comp.py" >index = 0
for post in result['posts']:
    os.system("curl -sq %s > /tmp/snack_tmp_%d" % (post['image'], index))
    index += 1</pre></p>
<p>ImageMagick is a powerful suite of tools, and in the next block we use the <a href="http://www.imagemagick.org/script/montage.php" target="_blank">montage command</a> to stitch our photos together.</p>
<p><strong><tt>-title</tt></strong>, as you might imagine, lets us write some title text onto the composite.  <strong><tt>-geometry</tt></strong> specifies the size and spacing of each image, 300px square, with 20px of vertical offset from the title. Lastly, <strong><tt>-tile</tt></strong> lays out the images in a 5 by 1 grid instead of stacking them in the default method.</p>
<p><pre class="lang:python start-line:26 decode:true " title="snack-comp.py" >p = subprocess.call(["montage",
                     "-title",
                     "Snack for %s\n%s - %s" % (tomorrow, result['title'], result['description']),
                     "-geometry", "300x300+0+20",
                     "-tile", "5x1",
                     "/tmp/snack_tmp_*",
                     "/tmp/snack_comp"])</pre></p>
<p>tinys3 is an awesomely light API to S3 uploads, and then we use the <a href="https://api.slack.com/incoming-webhooks" target="_blank">Slack Incoming Webhook integration</a> to send the message to chat.</p>
<p><pre class="lang:python start-line:34 decode:true " title="snack-comp.py" >conn = tinys3.Connection("AWS_ACCESS_KEY", "AWS_SECRET_KEY", tls=True)
with open("/tmp/snack_comp", "rb") as handle:
    conn.upload("snack-previews/snack_%s.jpg" % tomorrow, handle, "pack-uploads", public=True)

snack_comp_url = "http://pack-uploads.s3.amazonaws.com/snack-previews/snack_%s.jpg" % tomorrow

requests.post('https://hooks.slack.com/services/WEBHOOK/URL',
              data=json.dumps({"text": snack_comp_url}),
              headers={'content-type': 'application/json'})</pre></p>
<p>All in all a simple, effective piece code that drops needed information into our chat every morning.  Here's the whole listing for a complete picture.</p>
<p><pre class="lang:python decode:true " title="snack-comp.py" >import os
import json
import tinys3
import datetime
import requests
import subprocess

os.system("rm -f /tmp/snack_*")

tomorrow = datetime.date.today() + datetime.timedelta(days=1)

response = requests.get('http://packdog.com/api/snack.json',
                        params={'day_requested': 'today',
                                'year': tomorrow.year,
                                'month': tomorrow.month, 
                                'day': tomorrow.day})

response.raise_for_status()
result = response.json()

index = 0
for post in result['posts']:
    os.system("curl -sq %s > /tmp/snack_tmp_%d" % (post['image'], index))
    index += 1

p = subprocess.call(["montage",
                     "-title",
                     "Snack for %s\n%s - %s" % (tomorrow, result['title'], result['description']),
                     "-geometry", "300x300+0+20",
                     "-tile", "5x1",
                     "/tmp/snack_tmp_*",
                     "/tmp/snack_comp"])

conn = tinys3.Connection("AWS_ACCESS_KEY", "AWS_SECRET_KEY", tls=True)
with open("/tmp/snack_comp", "rb") as handle:
    conn.upload("snack-previews/snack_%s.jpg" % tomorrow, handle, "pack-uploads", public=True)

snack_comp_url = "http://pack-uploads.s3.amazonaws.com/snack-previews/snack_%s.jpg" % tomorrow

requests.post('https://hooks.slack.com/services/WEBHOOK/URL',
              data=json.dumps({"text": snack_comp_url}),
              headers={'content-type': 'application/json'})</pre></p>
<p>And here is an example of a random Snack that needed correction. Problem solved!</p>
<p style="text-align: center;"><img src="http://static.velvetcache.org/pages/2015/11/15/chat-ops-snack-preview-script/snack_2015-11-15.jpg" style="width: 90%;" /></p>
<p>Many thanks to <a href="https://github.com/smore-inc/tinys3" target="_blank">tinys3</a> and <a href="http://docs.python-requests.org/en/latest/" target="_blank">requests</a>.</p>